"use strict";(globalThis.webpackChunkpaads=globalThis.webpackChunkpaads||[]).push([[203],{4306:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"algorithms/sort/merge-sort","title":"Merge Sort","description":"Merge sort is a stable, comparison-based divide-and-conquer sorting algorithm. It works by recursively dividing the array into two halves, sorting each half, and then merging the sorted halves back together. It\'s known for its consistent O(n log n) performance regardless of the input data.","source":"@site/docs/algorithms/sort/merge-sort.md","sourceDirName":"algorithms/sort","slug":"/algorithms/sort/merge-sort","permalink":"/patterns-algorithms-and-data-structures/docs/algorithms/sort/merge-sort","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Bubble Sort","permalink":"/patterns-algorithms-and-data-structures/docs/algorithms/sort/bubble-sort"},"next":{"title":"Quick Sort","permalink":"/patterns-algorithms-and-data-structures/docs/algorithms/sort/quick-sort"}}');var t=r(4848),i=r(8453);const a={},l="Merge Sort",o={},d=[{value:"Algorithm Description",id:"algorithm-description",level:2},{value:"Time and Space Complexity",id:"time-and-space-complexity",level:2},{value:"Implementation",id:"implementation",level:2},{value:"Test Cases",id:"test-cases",level:2},{value:"When to Use Merge Sort",id:"when-to-use-merge-sort",level:2},{value:"Advantages and Disadvantages",id:"advantages-and-disadvantages",level:2},{value:"Visualization",id:"visualization",level:2},{value:"Variations",id:"variations",level:2}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"merge-sort",children:"Merge Sort"})}),"\n",(0,t.jsx)(n.p,{children:"Merge sort is a stable, comparison-based divide-and-conquer sorting algorithm. It works by recursively dividing the array into two halves, sorting each half, and then merging the sorted halves back together. It's known for its consistent O(n log n) performance regardless of the input data."}),"\n",(0,t.jsx)(n.h2,{id:"algorithm-description",children:"Algorithm Description"}),"\n",(0,t.jsx)(n.p,{children:"Merge sort follows the divide-and-conquer paradigm:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Divide:"})," Split the array into two halves at the middle point"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Conquer:"})," Recursively sort both halves"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Combine:"})," Merge the two sorted halves into a single sorted array"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"The key operation is the merge step, which combines two already sorted arrays into one sorted array by comparing elements and selecting the smaller one at each step."}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Base Case:"})," Arrays with 0 or 1 elements are considered already sorted."]}),"\n",(0,t.jsx)(n.h2,{id:"time-and-space-complexity",children:"Time and Space Complexity"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Time Complexity:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Best Case: O(n log n) - consistent performance"}),"\n",(0,t.jsx)(n.li,{children:"Average Case: O(n log n) - consistent performance"}),"\n",(0,t.jsx)(n.li,{children:"Worst Case: O(n log n) - consistent performance"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Space Complexity:"})," O(n) - requires additional space for temporary arrays during merging"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"implementation",children:"Implementation"}),"\n",(0,t.jsxs)(n.p,{children:["View the ",(0,t.jsx)(n.a,{href:"https://github.com/kostyngricuk/patterns-algorithms-and-data-structures/blob/master/examples/algorithms/sort/mergeSort/index.js",children:"merge sort implementation"})," on GitHub."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"const mergeSort = (arr) => {\n  // Base case: arrays with 0 or 1 element are already sorted\n  if (arr.length <= 1) {\n    return [...arr];\n  }\n  \n  // Divide the array into two halves\n  const mid = Math.floor(arr.length / 2);\n  const left = arr.slice(0, mid);\n  const right = arr.slice(mid);\n  \n  // Recursively sort both halves and merge them\n  return merge(mergeSort(left), mergeSort(right));\n};\n\nconst merge = (left, right) => {\n  const result = [];\n  let leftIndex = 0;\n  let rightIndex = 0;\n  \n  // Compare elements from left and right arrays and merge in ascending order\n  while (leftIndex < left.length && rightIndex < right.length) {\n    if (left[leftIndex] <= right[rightIndex]) {\n      result.push(left[leftIndex]);\n      leftIndex++;\n    } else {\n      result.push(right[rightIndex]);\n      rightIndex++;\n    }\n  }\n  \n  // Add remaining elements from left array (if any)\n  while (leftIndex < left.length) {\n    result.push(left[leftIndex]);\n    leftIndex++;\n  }\n  \n  // Add remaining elements from right array (if any)\n  while (rightIndex < right.length) {\n    result.push(right[rightIndex]);\n    rightIndex++;\n  }\n  \n  return result;\n};\n\nexport default mergeSort;\n"})}),"\n",(0,t.jsx)(n.h2,{id:"test-cases",children:"Test Cases"}),"\n",(0,t.jsxs)(n.p,{children:["View the ",(0,t.jsx)(n.a,{href:"https://github.com/kostyngricuk/patterns-algorithms-and-data-structures/blob/master/examples/algorithms/sort/mergeSort/index.test.js",children:"merge sort tests"})," on GitHub."]}),"\n",(0,t.jsx)(n.p,{children:"The implementation includes comprehensive test cases that verify:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Sorting unsorted arrays:"})," Correctly sorts random unsorted data"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"const arr = [64, 34, 25, 12, 22, 11, 90];\nmergeSort(arr); // Returns [11, 12, 22, 25, 34, 64, 90]\n"})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Handling already sorted arrays:"})," Maintains efficiency on sorted data"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"const arr = [1, 2, 3, 4, 5];\nmergeSort(arr); // Returns [1, 2, 3, 4, 5]\n"})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Managing duplicate elements:"})," Correctly handles arrays with repeated values (stable sort)"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"const arr = [5, 2, 8, 2, 9, 1, 5];\nmergeSort(arr); // Returns [1, 2, 2, 5, 5, 8, 9]\n"})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Handling reverse sorted arrays:"})," Efficiently sorts arrays in reverse order"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"const arr = [5, 4, 3, 2, 1];\nmergeSort(arr); // Returns [1, 2, 3, 4, 5]\n"})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Edge cases:"})," Handles empty arrays, single elements, and two elements"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"mergeSort([]); // Returns []\nmergeSort([42]); // Returns [42]\nmergeSort([2, 1]); // Returns [1, 2]\n"})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Large arrays:"})," Efficiently handles large datasets with consistent performance"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Non-destructive sorting:"})," Does not mutate the original array"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"when-to-use-merge-sort",children:"When to Use Merge Sort"}),"\n",(0,t.jsx)(n.p,{children:"Merge sort is appropriate when:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"You need guaranteed O(n log n) performance"}),"\n",(0,t.jsx)(n.li,{children:"Stability is required (preserving relative order of equal elements)"}),"\n",(0,t.jsx)(n.li,{children:"You're working with large datasets"}),"\n",(0,t.jsx)(n.li,{children:"Consistent performance is more important than memory usage"}),"\n",(0,t.jsx)(n.li,{children:"You need predictable behavior regardless of input characteristics"}),"\n",(0,t.jsx)(n.li,{children:"External sorting is needed (sorting data that doesn't fit in memory)"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"advantages-and-disadvantages",children:"Advantages and Disadvantages"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Advantages:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Guaranteed O(n log n) time complexity in all cases"}),"\n",(0,t.jsx)(n.li,{children:"Stable sorting algorithm (maintains relative order of equal elements)"}),"\n",(0,t.jsx)(n.li,{children:"Predictable performance regardless of input data"}),"\n",(0,t.jsx)(n.li,{children:"Well-suited for linked lists (can be implemented with O(1) space for lists)"}),"\n",(0,t.jsx)(n.li,{children:"Excellent for external sorting (large datasets)"}),"\n",(0,t.jsx)(n.li,{children:"Parallelizable (can sort subarrays in parallel)"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Disadvantages:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Requires O(n) additional space for temporary arrays"}),"\n",(0,t.jsx)(n.li,{children:"Not in-place (uses extra memory)"}),"\n",(0,t.jsx)(n.li,{children:"Slower than quick sort on average due to higher constant factors"}),"\n",(0,t.jsx)(n.li,{children:"Not adaptive (doesn't benefit from partially sorted data)"}),"\n",(0,t.jsx)(n.li,{children:"More complex than simple algorithms like bubble sort or selection sort"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"visualization",children:"Visualization"}),"\n",(0,t.jsx)(n.p,{children:"The algorithm can be visualized as a binary tree:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Divide phase:"})," Split arrays in half recursively (top-down)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Merge phase:"})," Combine sorted subarrays (bottom-up)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Tree depth:"})," log n levels"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Work per level:"})," O(n) comparisons and merges"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Each level of the recursion tree processes all n elements, and there are log n levels, resulting in O(n log n) total work."}),"\n",(0,t.jsx)(n.h2,{id:"variations",children:"Variations"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Bottom-up merge sort:"})," Iterative implementation that avoids recursion"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Natural merge sort:"})," Takes advantage of existing runs (sorted subsequences)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"In-place merge sort:"})," Attempts to reduce space complexity (complex to implement)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Multi-way merge sort:"})," Divides into more than two parts for better cache performance"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>a,x:()=>l});var s=r(6540);const t={},i=s.createContext(t);function a(e){const n=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);