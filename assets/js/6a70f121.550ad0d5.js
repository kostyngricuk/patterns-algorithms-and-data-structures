"use strict";(globalThis.webpackChunkpaads=globalThis.webpackChunkpaads||[]).push([[325],{2390:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>h,contentTitle:()=>l,default:()=>o,frontMatter:()=>a,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"algorithms/search/linear-search","title":"Linear Search","description":"Linear search is a simple searching algorithm that finds the position of a target value within an array. It sequentially checks each element of the array until a match is found or the entire array has been searched.","source":"@site/docs/algorithms/search/linear-search.md","sourceDirName":"algorithms/search","slug":"/algorithms/search/linear-search","permalink":"/patterns-algorithms-and-data-structures/docs/algorithms/search/linear-search","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Binary Search","permalink":"/patterns-algorithms-and-data-structures/docs/algorithms/search/binary-search"},"next":{"title":"Sort Algorithms","permalink":"/patterns-algorithms-and-data-structures/docs/category/sort-algorithms"}}');var t=s(4848),i=s(8453);const a={},l="Linear Search",h={},c=[{value:"Algorithm Description",id:"algorithm-description",level:2},{value:"Time and Space Complexity",id:"time-and-space-complexity",level:2},{value:"Implementation",id:"implementation",level:2},{value:"Test Cases",id:"test-cases",level:2},{value:"Use Cases",id:"use-cases",level:2},{value:"Advantages and Disadvantages",id:"advantages-and-disadvantages",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"linear-search",children:"Linear Search"})}),"\n",(0,t.jsx)(n.p,{children:"Linear search is a simple searching algorithm that finds the position of a target value within an array. It sequentially checks each element of the array until a match is found or the entire array has been searched."}),"\n",(0,t.jsx)(n.h2,{id:"algorithm-description",children:"Algorithm Description"}),"\n",(0,t.jsx)(n.p,{children:"Linear search works by examining each element in the array one by one, starting from the first element, until either:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"The target element is found (returns the index)"}),"\n",(0,t.jsx)(n.li,{children:"The end of the array is reached without finding the target (returns -1)"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"time-and-space-complexity",children:"Time and Space Complexity"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Time Complexity:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Best Case: O(1) - when the target is the first element"}),"\n",(0,t.jsx)(n.li,{children:"Average Case: O(n) - when the target is in the middle"}),"\n",(0,t.jsx)(n.li,{children:"Worst Case: O(n) - when the target is the last element or not present"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Space Complexity:"})," O(1) - uses constant extra space"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"implementation",children:"Implementation"}),"\n",(0,t.jsxs)(n.p,{children:["View the ",(0,t.jsx)(n.a,{href:"https://github.com/kostyngricuk/patterns-algorithms-and-data-structures/blob/master/examples/algorithms/search/linearSearch/index.js",children:"linear search implementation"})," on GitHub."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"const linearSearch = (arr, target) => {\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] === target) {\n      return i;\n    }\n  }\n\n  return -1;\n};\n\nexport default linearSearch;\n"})}),"\n",(0,t.jsx)(n.h2,{id:"test-cases",children:"Test Cases"}),"\n",(0,t.jsxs)(n.p,{children:["View the ",(0,t.jsx)(n.a,{href:"https://github.com/kostyngricuk/patterns-algorithms-and-data-structures/blob/master/examples/algorithms/search/linearSearch/index.test.js",children:"linear search tests"})," on GitHub."]}),"\n",(0,t.jsx)(n.p,{children:"The implementation includes comprehensive test cases that verify:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Finding existing elements:"})," Returns the correct index when the target element exists in the array"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"const arr = [1, 2, 3, 4, 5];\nlinearSearch(arr, 3); // Returns 2\nlinearSearch(arr, 4); // Returns 3\n"})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Handling non-existent elements:"})," Returns -1 when the target element is not found"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"const arr = [1, 2, 3, 4, 5];\nlinearSearch(arr, 6); // Returns -1\n"})}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"use-cases",children:"Use Cases"}),"\n",(0,t.jsx)(n.p,{children:"Linear search is useful when:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"The array is small (overhead of more complex algorithms isn't justified)"}),"\n",(0,t.jsx)(n.li,{children:"The array is unsorted (binary search requires sorted data)"}),"\n",(0,t.jsx)(n.li,{children:"You need to search only once (not worth sorting first)"}),"\n",(0,t.jsx)(n.li,{children:"Memory is extremely limited"}),"\n",(0,t.jsx)(n.li,{children:"The data structure doesn't support random access (e.g., linked lists)"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Common applications include:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Searching in small lists"}),"\n",(0,t.jsx)(n.li,{children:"Finding elements in unsorted arrays"}),"\n",(0,t.jsx)(n.li,{children:"One-time searches where sorting overhead isn't justified"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"advantages-and-disadvantages",children:"Advantages and Disadvantages"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Advantages:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Simple to understand and implement"}),"\n",(0,t.jsx)(n.li,{children:"Works on unsorted arrays"}),"\n",(0,t.jsx)(n.li,{children:"Requires minimal memory"}),"\n",(0,t.jsx)(n.li,{children:"No preprocessing required"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Disadvantages:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Inefficient for large datasets"}),"\n",(0,t.jsx)(n.li,{children:"Time complexity is linear O(n)"}),"\n"]})]})}function o(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>l});var r=s(6540);const t={},i=r.createContext(t);function a(e){const n=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);