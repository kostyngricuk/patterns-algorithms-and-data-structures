"use strict";(globalThis.webpackChunkpaads=globalThis.webpackChunkpaads||[]).push([[693],{7872:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>a,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"algorithms/sort/selection-sort","title":"Selection Sort","description":"Selection sort is a simple comparison-based sorting algorithm. It works by dividing the array into two parts: a sorted portion at the beginning and an unsorted portion at the end. The algorithm repeatedly finds the minimum element from the unsorted portion and swaps it with the first element of the unsorted portion.","source":"@site/docs/algorithms/sort/selection-sort.md","sourceDirName":"algorithms/sort","slug":"/algorithms/sort/selection-sort","permalink":"/patterns-algorithms-and-data-structures/docs/algorithms/sort/selection-sort","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Quick Sort","permalink":"/patterns-algorithms-and-data-structures/docs/algorithms/sort/quick-sort"}}');var i=s(4848),r=s(8453);const a={},l="Selection Sort",o={},d=[{value:"Algorithm Description",id:"algorithm-description",level:2},{value:"Time and Space Complexity",id:"time-and-space-complexity",level:2},{value:"Implementation",id:"implementation",level:2},{value:"Test Cases",id:"test-cases",level:2},{value:"When to Use Selection Sort",id:"when-to-use-selection-sort",level:2},{value:"Advantages and Disadvantages",id:"advantages-and-disadvantages",level:2},{value:"Visualization",id:"visualization",level:2}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"selection-sort",children:"Selection Sort"})}),"\n",(0,i.jsx)(n.p,{children:"Selection sort is a simple comparison-based sorting algorithm. It works by dividing the array into two parts: a sorted portion at the beginning and an unsorted portion at the end. The algorithm repeatedly finds the minimum element from the unsorted portion and swaps it with the first element of the unsorted portion."}),"\n",(0,i.jsx)(n.h2,{id:"algorithm-description",children:"Algorithm Description"}),"\n",(0,i.jsx)(n.p,{children:"Selection sort works by maintaining two subarrays:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Sorted subarray:"})," Initially empty, grows from left to right"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Unsorted subarray:"})," Initially the entire array, shrinks from left to right"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"The algorithm process:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Find the minimum element in the unsorted subarray"}),"\n",(0,i.jsx)(n.li,{children:"Swap it with the first element of the unsorted subarray"}),"\n",(0,i.jsx)(n.li,{children:"Move the boundary between sorted and unsorted subarrays one position to the right"}),"\n",(0,i.jsx)(n.li,{children:"Repeat until the entire array is sorted"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"time-and-space-complexity",children:"Time and Space Complexity"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Time Complexity:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Best Case: O(n\xb2) - even if the array is already sorted"}),"\n",(0,i.jsx)(n.li,{children:"Average Case: O(n\xb2) - typical case with random data"}),"\n",(0,i.jsx)(n.li,{children:"Worst Case: O(n\xb2) - consistently quadratic regardless of input"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Space Complexity:"})," O(1) - uses constant extra space (in-place sorting)"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"implementation",children:"Implementation"}),"\n",(0,i.jsxs)(n.p,{children:["View the ",(0,i.jsx)(n.a,{href:"https://github.com/kostyngricuk/patterns-algorithms-and-data-structures/blob/master/examples/algorithms/sort/selectionSort/index.js",children:"selection sort implementation"})," on GitHub."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const selectionSort = (arr) => {\n  const result = [...arr]; // Create a copy to avoid mutating the original array\n  const n = result.length;\n\n  for (let i = 0; i < n - 1; i++) {\n    // Find the minimum element in the remaining unsorted array\n    let minIndex = i;\n    \n    for (let j = i + 1; j < n; j++) {\n      if (result[j] < result[minIndex]) {\n        minIndex = j;\n      }\n    }\n    \n    // Swap the found minimum element with the first element\n    if (minIndex !== i) {\n      [result[i], result[minIndex]] = [result[minIndex], result[i]];\n    }\n  }\n\n  return result;\n};\n\nexport default selectionSort;\n"})}),"\n",(0,i.jsx)(n.h2,{id:"test-cases",children:"Test Cases"}),"\n",(0,i.jsxs)(n.p,{children:["View the ",(0,i.jsx)(n.a,{href:"https://github.com/kostyngricuk/patterns-algorithms-and-data-structures/blob/master/examples/algorithms/sort/selectionSort/index.test.js",children:"selection sort tests"})," on GitHub."]}),"\n",(0,i.jsx)(n.p,{children:"The implementation includes comprehensive test cases that verify:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Sorting unsorted arrays:"})," Correctly sorts random unsorted data"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const arr = [64, 25, 12, 22, 11];\nselectionSort(arr); // Returns [11, 12, 22, 25, 64]\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Handling already sorted arrays:"})," Processes sorted data (still O(n\xb2))"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const arr = [1, 2, 3, 4, 5];\nselectionSort(arr); // Returns [1, 2, 3, 4, 5]\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Managing duplicate elements:"})," Correctly handles arrays with repeated values"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const arr = [5, 2, 8, 2, 9, 1, 5];\nselectionSort(arr); // Returns [1, 2, 2, 5, 5, 8, 9]\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Handling reverse sorted arrays:"})," Efficiently sorts arrays in reverse order"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const arr = [5, 4, 3, 2, 1];\nselectionSort(arr); // Returns [1, 2, 3, 4, 5]\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Edge cases:"})," Handles empty arrays and single-element arrays"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"selectionSort([]); // Returns []\nselectionSort([42]); // Returns [42]\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Non-destructive sorting:"})," Does not mutate the original array"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"when-to-use-selection-sort",children:"When to Use Selection Sort"}),"\n",(0,i.jsx)(n.p,{children:"Selection sort is appropriate when:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"The dataset is small (< 20 elements)"}),"\n",(0,i.jsx)(n.li,{children:"Memory writes are expensive (minimizes the number of swaps)"}),"\n",(0,i.jsx)(n.li,{children:"Simplicity is preferred over performance"}),"\n",(0,i.jsx)(n.li,{children:"You need a stable in-place sorting algorithm"}),"\n",(0,i.jsx)(n.li,{children:"Educational purposes or algorithm learning"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"advantages-and-disadvantages",children:"Advantages and Disadvantages"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Advantages:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Simple to understand and implement"}),"\n",(0,i.jsx)(n.li,{children:"In-place sorting (O(1) space complexity)"}),"\n",(0,i.jsx)(n.li,{children:"Minimizes the number of swaps (at most n-1 swaps)"}),"\n",(0,i.jsx)(n.li,{children:"Performs well on small datasets"}),"\n",(0,i.jsx)(n.li,{children:"No additional memory requirements"}),"\n",(0,i.jsx)(n.li,{children:"Not affected by the initial order of elements"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Disadvantages:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Inefficient for large datasets O(n\xb2)"}),"\n",(0,i.jsx)(n.li,{children:"Not adaptive (doesn't perform better on partially sorted arrays)"}),"\n",(0,i.jsx)(n.li,{children:"Not stable (can change the relative order of equal elements)"}),"\n",(0,i.jsx)(n.li,{children:"Makes O(n\xb2) comparisons even when the array is already sorted"}),"\n",(0,i.jsx)(n.li,{children:"Generally outperformed by other algorithms like insertion sort"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"visualization",children:"Visualization"}),"\n",(0,i.jsx)(n.p,{children:"The algorithm can be visualized as:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Pass 1:"})," Find minimum in entire array, place at position 0"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Pass 2:"})," Find minimum in positions 1 to n-1, place at position 1"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Pass 3:"})," Find minimum in positions 2 to n-1, place at position 2"]}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.strong,{children:"And so on..."})}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"After each pass, one more element is in its final sorted position at the beginning of the array."})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>l});var t=s(6540);const i={},r=t.createContext(i);function a(e){const n=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);