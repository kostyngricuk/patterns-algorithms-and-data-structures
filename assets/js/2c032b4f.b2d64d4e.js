"use strict";(globalThis.webpackChunkpaads=globalThis.webpackChunkpaads||[]).push([[783],{905:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>h,contentTitle:()=>l,default:()=>o,frontMatter:()=>i,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"algorithms/search/binary-search","title":"Binary Search","description":"Binary search is an efficient searching algorithm that finds the position of a target value within a sorted array. It works by repeatedly dividing the search interval in half, comparing the target with the middle element, and eliminating half of the remaining elements at each step.","source":"@site/docs/algorithms/search/binary-search.md","sourceDirName":"algorithms/search","slug":"/algorithms/search/binary-search","permalink":"/patterns-algorithms-and-data-structures/docs/algorithms/search/binary-search","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Search Algorithms","permalink":"/patterns-algorithms-and-data-structures/docs/category/search-algorithms"},"next":{"title":"Linear Search","permalink":"/patterns-algorithms-and-data-structures/docs/algorithms/search/linear-search"}}');var a=r(4848),s=r(8453);const i={},l="Binary Search",h={},c=[{value:"Algorithm Description",id:"algorithm-description",level:2},{value:"Time and Space Complexity",id:"time-and-space-complexity",level:2},{value:"Implementation",id:"implementation",level:2},{value:"Test Cases",id:"test-cases",level:2},{value:"When to Use Binary Search",id:"when-to-use-binary-search",level:2},{value:"Advantages and Disadvantages",id:"advantages-and-disadvantages",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"binary-search",children:"Binary Search"})}),"\n",(0,a.jsxs)(n.p,{children:["Binary search is an efficient searching algorithm that finds the position of a target value within a ",(0,a.jsx)(n.strong,{children:"sorted"})," array. It works by repeatedly dividing the search interval in half, comparing the target with the middle element, and eliminating half of the remaining elements at each step."]}),"\n",(0,a.jsx)(n.h2,{id:"algorithm-description",children:"Algorithm Description"}),"\n",(0,a.jsx)(n.p,{children:"Binary search works by maintaining two pointers (minIndex and maxIndex) that define the current search range. The algorithm:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"Calculates the middle index of the current range"}),"\n",(0,a.jsx)(n.li,{children:"Compares the middle element with the target"}),"\n",(0,a.jsx)(n.li,{children:"If they match, returns the index"}),"\n",(0,a.jsx)(n.li,{children:"If the middle element is less than the target, searches the right half"}),"\n",(0,a.jsx)(n.li,{children:"If the middle element is greater than the target, searches the left half"}),"\n",(0,a.jsx)(n.li,{children:"Repeats until the target is found or the search range is exhausted"}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Important:"})," Binary search only works on sorted arrays."]}),"\n",(0,a.jsx)(n.h2,{id:"time-and-space-complexity",children:"Time and Space Complexity"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Time Complexity:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Best Case: O(1) - when the target is the middle element"}),"\n",(0,a.jsx)(n.li,{children:"Average Case: O(log n) - logarithmic time complexity"}),"\n",(0,a.jsx)(n.li,{children:"Worst Case: O(log n) - when the target is not present or at the extremes"}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Space Complexity:"})," O(1) - uses constant extra space (iterative implementation)"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"implementation",children:"Implementation"}),"\n",(0,a.jsxs)(n.p,{children:["View the ",(0,a.jsx)(n.a,{href:"https://github.com/kostyngricuk/patterns-algorithms-and-data-structures/blob/master/examples/algorithms/search/binarySearch/index.js",children:"binary search implementation"})," on GitHub."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"// arr - should be sorted array\nconst binarySearch = (arr, target) => {\n  let minIndex = 0;\n  let maxIndex = arr.length - 1;\n\n  while (minIndex <= maxIndex) {\n    const midIndex = Math.floor((minIndex + maxIndex) / 2);\n    if (arr[midIndex] === target) {\n      return midIndex;\n    }\n\n    if (arr[midIndex] < target) {\n      minIndex = midIndex + 1;\n    }\n    if (arr[midIndex] > target) {\n      maxIndex = midIndex - 1;\n    }\n  }\n\n  return -1;\n}\n\nexport default binarySearch;\n"})}),"\n",(0,a.jsx)(n.h2,{id:"test-cases",children:"Test Cases"}),"\n",(0,a.jsxs)(n.p,{children:["View the ",(0,a.jsx)(n.a,{href:"https://github.com/kostyngricuk/patterns-algorithms-and-data-structures/blob/master/examples/algorithms/search/binarySearch/index.test.js",children:"binary search tests"})," on GitHub."]}),"\n",(0,a.jsx)(n.p,{children:"The implementation includes comprehensive test cases that verify:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Finding existing elements in sorted arrays:"})," Returns the correct index when the target element exists"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const arr = [1, 2, 3, 4, 5]; // sorted array\nbinarySearch(arr, 3); // Returns 2\nbinarySearch(arr, 4); // Returns 3\n"})}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Handling non-existent elements:"})," Returns -1 when the target element is not found"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const arr = [1, 2, 3, 4, 5];\nbinarySearch(arr, 6); // Returns -1\n"})}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Handling unsorted arrays:"})," Returns -1 for unsorted arrays (requirement not met)"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const arr = [3, 4, 5, 1, 2]; // unsorted array\nbinarySearch(arr, 1); // Returns -1 (even though 1 exists)\n"})}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"when-to-use-binary-search",children:"When to Use Binary Search"}),"\n",(0,a.jsx)(n.p,{children:"Binary search is appropriate when:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"The array is sorted (prerequisite)"}),"\n",(0,a.jsx)(n.li,{children:"You need to perform multiple searches on the same dataset"}),"\n",(0,a.jsx)(n.li,{children:"The dataset is large (significant performance improvement over linear search)"}),"\n",(0,a.jsx)(n.li,{children:"Memory usage is not a primary concern for preprocessing"}),"\n",(0,a.jsx)(n.li,{children:"Fast search time is critical"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"advantages-and-disadvantages",children:"Advantages and Disadvantages"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Advantages:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Very efficient for large sorted datasets O(log n)"}),"\n",(0,a.jsx)(n.li,{children:"Predictable performance characteristics"}),"\n",(0,a.jsx)(n.li,{children:"Simple to understand and implement"}),"\n",(0,a.jsx)(n.li,{children:"Much faster than linear search for large arrays"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Disadvantages:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Requires the array to be sorted (preprocessing overhead)"}),"\n",(0,a.jsx)(n.li,{children:"Only works on sorted data structures"}),"\n",(0,a.jsx)(n.li,{children:"More complex than linear search"}),"\n",(0,a.jsx)(n.li,{children:"Requires random access to elements (not suitable for linked lists)"}),"\n"]})]})}function o(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>i,x:()=>l});var t=r(6540);const a={},s=t.createContext(a);function i(e){const n=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);