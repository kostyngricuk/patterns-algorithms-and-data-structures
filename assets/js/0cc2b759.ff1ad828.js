"use strict";(globalThis.webpackChunkpaads=globalThis.webpackChunkpaads||[]).push([[360],{2956:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"algorithms/sort/quick-sort","title":"Quick Sort","description":"Quick sort is a highly efficient divide-and-conquer sorting algorithm. It works by selecting a \'pivot\' element from the array and partitioning the other elements into two subarrays according to whether they are less than or greater than the pivot. The subarrays are then sorted recursively.","source":"@site/docs/algorithms/sort/quick-sort.md","sourceDirName":"algorithms/sort","slug":"/algorithms/sort/quick-sort","permalink":"/patterns-algorithms-and-data-structures/docs/algorithms/sort/quick-sort","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Merge Sort","permalink":"/patterns-algorithms-and-data-structures/docs/algorithms/sort/merge-sort"},"next":{"title":"Selection Sort","permalink":"/patterns-algorithms-and-data-structures/docs/algorithms/sort/selection-sort"}}');var t=r(4848),s=r(8453);const a={},l="Quick Sort",o={},c=[{value:"Algorithm Description",id:"algorithm-description",level:2},{value:"Time and Space Complexity",id:"time-and-space-complexity",level:2},{value:"Implementation",id:"implementation",level:2},{value:"Test Cases",id:"test-cases",level:2},{value:"When to Use Quick Sort",id:"when-to-use-quick-sort",level:2},{value:"Advantages and Disadvantages",id:"advantages-and-disadvantages",level:2},{value:"Pivot Selection Strategies",id:"pivot-selection-strategies",level:2},{value:"Optimization Techniques",id:"optimization-techniques",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"quick-sort",children:"Quick Sort"})}),"\n",(0,t.jsx)(n.p,{children:"Quick sort is a highly efficient divide-and-conquer sorting algorithm. It works by selecting a 'pivot' element from the array and partitioning the other elements into two subarrays according to whether they are less than or greater than the pivot. The subarrays are then sorted recursively."}),"\n",(0,t.jsx)(n.h2,{id:"algorithm-description",children:"Algorithm Description"}),"\n",(0,t.jsx)(n.p,{children:"Quick sort follows the divide-and-conquer approach:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Choose a pivot:"})," Select an element from the array (commonly the last element)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Partition:"})," Rearrange the array so that:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Elements smaller than the pivot come before it"}),"\n",(0,t.jsx)(n.li,{children:"Elements greater than the pivot come after it"}),"\n",(0,t.jsx)(n.li,{children:"The pivot is now in its final sorted position"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Divide:"})," Recursively apply quick sort to the subarrays on either side of the pivot"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Conquer:"})," The base case is when the subarray has 0 or 1 elements (already sorted)"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"The partitioning step is crucial and determines the algorithm's efficiency."}),"\n",(0,t.jsx)(n.h2,{id:"time-and-space-complexity",children:"Time and Space Complexity"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Time Complexity:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Best Case: O(n log n) - when the pivot divides the array into equal halves"}),"\n",(0,t.jsx)(n.li,{children:"Average Case: O(n log n) - with random pivot selection"}),"\n",(0,t.jsx)(n.li,{children:"Worst Case: O(n\xb2) - when the pivot is always the smallest or largest element"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Space Complexity:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Best/Average Case: O(log n) - due to recursion stack"}),"\n",(0,t.jsx)(n.li,{children:"Worst Case: O(n) - when the recursion depth reaches n"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"implementation",children:"Implementation"}),"\n",(0,t.jsxs)(n.p,{children:["View the ",(0,t.jsx)(n.a,{href:"https://github.com/kostyngricuk/patterns-algorithms-and-data-structures/blob/master/examples/algorithms/sort/quickSort/index.js",children:"quick sort implementation"})," on GitHub."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"const quickSort = (arr) => {\n  // Create a copy to avoid mutating the original array\n  const result = [...arr];\n  \n  const quickSortHelper = (array, low, high) => {\n    if (low < high) {\n      // Partition the array and get the pivot index\n      const pivotIndex = partition(array, low, high);\n      \n      // Recursively sort elements before and after partition\n      quickSortHelper(array, low, pivotIndex - 1);\n      quickSortHelper(array, pivotIndex + 1, high);\n    }\n  };\n  \n  const partition = (array, low, high) => {\n    // Choose the rightmost element as pivot\n    const pivot = array[high];\n    let i = low - 1; // Index of smaller element\n    \n    for (let j = low; j < high; j++) {\n      // If current element is smaller than or equal to pivot\n      if (array[j] <= pivot) {\n        i++;\n        [array[i], array[j]] = [array[j], array[i]];\n      }\n    }\n    \n    // Place pivot in correct position\n    [array[i + 1], array[high]] = [array[high], array[i + 1]];\n    return i + 1;\n  };\n  \n  quickSortHelper(result, 0, result.length - 1);\n  return result;\n};\n\nexport default quickSort;\n"})}),"\n",(0,t.jsx)(n.h2,{id:"test-cases",children:"Test Cases"}),"\n",(0,t.jsxs)(n.p,{children:["View the ",(0,t.jsx)(n.a,{href:"https://github.com/kostyngricuk/patterns-algorithms-and-data-structures/blob/master/examples/algorithms/sort/quickSort/index.test.js",children:"quick sort tests"})," on GitHub."]}),"\n",(0,t.jsx)(n.p,{children:"The implementation includes comprehensive test cases that verify:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Sorting unsorted arrays:"})," Correctly sorts random unsorted data"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"const arr = [64, 34, 25, 12, 22, 11, 90];\nquickSort(arr); // Returns [11, 12, 22, 25, 34, 64, 90]\n"})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Handling already sorted arrays:"})," Processes sorted data efficiently"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"const arr = [1, 2, 3, 4, 5];\nquickSort(arr); // Returns [1, 2, 3, 4, 5]\n"})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Managing duplicate elements:"})," Correctly handles arrays with repeated values"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"const arr = [5, 2, 8, 2, 9, 1, 5];\nquickSort(arr); // Returns [1, 2, 2, 5, 5, 8, 9]\n"})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Handling reverse sorted arrays:"})," Efficiently sorts arrays in reverse order"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"const arr = [5, 4, 3, 2, 1];\nquickSort(arr); // Returns [1, 2, 3, 4, 5]\n"})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Edge cases:"})," Handles empty arrays, single elements, and two elements"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"quickSort([]); // Returns []\nquickSort([42]); // Returns [42]\nquickSort([2, 1]); // Returns [1, 2]\n"})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Non-destructive sorting:"})," Does not mutate the original array"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"when-to-use-quick-sort",children:"When to Use Quick Sort"}),"\n",(0,t.jsx)(n.p,{children:"Quick sort is appropriate when:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"You need efficient general-purpose sorting (average O(n log n))"}),"\n",(0,t.jsx)(n.li,{children:"Memory usage should be minimal (in-place sorting possible)"}),"\n",(0,t.jsx)(n.li,{children:"The dataset is large and performance is critical"}),"\n",(0,t.jsx)(n.li,{children:"You can implement optimizations like randomized pivot selection"}),"\n",(0,t.jsx)(n.li,{children:"Stability is not required (quick sort is not stable)"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"advantages-and-disadvantages",children:"Advantages and Disadvantages"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Advantages:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Very efficient average-case performance O(n log n)"}),"\n",(0,t.jsx)(n.li,{children:"In-place sorting possible (though this implementation creates a copy)"}),"\n",(0,t.jsx)(n.li,{children:"Good cache performance due to locality of reference"}),"\n",(0,t.jsx)(n.li,{children:"Widely used and well-understood"}),"\n",(0,t.jsx)(n.li,{children:"Can be optimized with various pivot selection strategies"}),"\n",(0,t.jsx)(n.li,{children:"Performs well on most real-world data"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Disadvantages:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Worst-case time complexity is O(n\xb2)"}),"\n",(0,t.jsx)(n.li,{children:"Not stable (can change relative order of equal elements)"}),"\n",(0,t.jsx)(n.li,{children:"Performance depends heavily on pivot selection"}),"\n",(0,t.jsx)(n.li,{children:"Can have poor performance on already sorted data (with naive pivot)"}),"\n",(0,t.jsx)(n.li,{children:"Recursive implementation uses O(log n) to O(n) stack space"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"pivot-selection-strategies",children:"Pivot Selection Strategies"}),"\n",(0,t.jsx)(n.p,{children:"Different pivot selection methods affect performance:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Last element"})," (used in this implementation): Simple but can be inefficient"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"First element"}),": Similar issues as last element"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Random element"}),": Better average performance, avoids worst-case on sorted data"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Median-of-three"}),": Choose median of first, middle, and last elements"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Median-of-medians"}),": Guarantees O(n log n) time complexity"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"optimization-techniques",children:"Optimization Techniques"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Hybrid approach"}),": Switch to insertion sort for small subarrays (< 10 elements)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Three-way partitioning"}),": Handle duplicate elements more efficiently"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Iterative implementation"}),": Reduce space complexity by avoiding recursion"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Tail recursion optimization"}),": Optimize the recursive calls"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>a,x:()=>l});var i=r(6540);const t={},s=i.createContext(t);function a(e){const n=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);